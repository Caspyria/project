pipeline {
    agent any // This means Jenkins will run on any available agent (including the controller if allowed).
              // For production, you'd typically specify a label, e.g., agent { label 'docker-agent' }

    environment {
        // Define a variable for your Docker image name for consistency
        DOCKER_IMAGE_NAME = 'my-nginx-image'
        // Define the path to Docker if it's not in the default system PATH
        // This makes it available for all steps in the pipeline.
        // Adjust '/usr/local/bin' if Docker is in a different location on your agent.
        // Alternatively, ensure Docker is in the system-wide PATH on your Jenkins agent.
        // DOCKER_BIN_PATH = '/usr/local/bin' // Uncomment and set if needed
    }

    stages {
        stage('Checkout SCM') { // Renamed for clarity as per your initial screenshot
            steps {
                git branch: 'main', url: 'https://github.com/Caspyria/project.git'
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    // Prepend DOCKER_BIN_PATH if it's defined, otherwise just execute docker
                    def dockerCmdPrefix = ''
                    if (env.DOCKER_BIN_PATH) {
                        dockerCmdPrefix = "export PATH=\"${env.DOCKER_BIN_PATH}:\$PATH\"; "
                    }

                    // Build the Docker image with a tag including the BUILD_NUMBER
                    // Use the DOCKER_IMAGE_NAME from environment
                    sh "${dockerCmdPrefix}docker build -t \"${env.DOCKER_IMAGE_NAME}:${env.BUILD_NUMBER}\" ."
                }
            }
        }

        stage('Stop & Remove Old Container') {
            steps {
                script {
                    def dockerCmdPrefix = ''
                    if (env.DOCKER_BIN_PATH) {
                        dockerCmdPrefix = "export PATH=\"${env.DOCKER_BIN_PATH}:\$PATH\"; "
                    }

                    sh """
                        ${dockerCmdPrefix}if [ \$(docker ps -q -f name=my-nginx-container) ]; then
                            echo "Stopping and removing existing container 'my-nginx-container'..."
                            ${dockerCmdPrefix}docker rm -f my-nginx-container
                        else
                            echo "No existing container 'my-nginx-container' found."
                        fi
                    """
                }
            }
        }

        stage('Run Docker Container') {
            steps {
                script {
                    def dockerCmdPrefix = ''
                    if (env.DOCKER_BIN_PATH) {
                        dockerCmdPrefix = "export PATH=\"${env.DOCKER_BIN_PATH}:\$PATH\"; "
                    }

                    // Run the new container, mapping port 8081 on host to 80 in container
                    // Use the DOCKER_IMAGE_NAME and BUILD_NUMBER
                    sh "${dockerCmdPrefix}docker run -d --name my-nginx-container -p 8081:80 \"${env.DOCKER_IMAGE_NAME}:${env.BUILD_NUMBER}\""
                }
            }
        }
    }

    post {
        success {
            echo 'Deployment successful! Container running on port 8081.'
            echo 'You can access it at http://localhost:8081 (if accessed from the host running Jenkins).'
            // Consider removing or commenting out the 'open' command if not on a macOS desktop agent
            // sh 'open http://localhost:8081' // This command is macOS-specific and not suitable for server-side Jenkins
        }
        failure {
            echo 'Build or deployment failed. Check the logs for details.'
        }
        always {
            echo 'Pipeline execution complete.'
        }
    }
}
